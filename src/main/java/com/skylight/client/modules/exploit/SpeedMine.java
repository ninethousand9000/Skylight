package com.skylight.client.modules.exploit;

import com.mojang.realmsclient.gui.ChatFormatting;
import com.skylight.base.events.EventType;
import com.skylight.base.events.events.BlockEvent;
import com.skylight.base.events.events.RenderEvent3D;
import com.skylight.base.features.modules.Module;
import com.skylight.base.features.modules.ModuleAnnotation;
import com.skylight.base.features.modules.ModuleCategory;
import com.skylight.base.mixins.accessors.IRenderControllerMP;
import com.skylight.base.settings.NumberSetting;
import com.skylight.base.settings.ParentSetting;
import com.skylight.base.settings.Setting;
import com.skylight.base.utils.chat.ChatUtils;
import com.skylight.base.utils.game.BlockUtils;
import com.skylight.base.utils.game.PlayerUtils;
import com.skylight.base.utils.render.NewRender3DUtils;
import com.skylight.base.utils.rotation.RotationUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;

@ModuleAnnotation(category = ModuleCategory.Exploit)
public class SpeedMine extends Module {
    public static final Setting<Boolean> rangeCheck = new Setting<>("RangeCheck", true);
    public static final NumberSetting<Integer> range = new NumberSetting<>("Range", 1, 10, 30, 1);
    public static final Setting<Boolean> swing = new Setting<>("Swing", true);
    public static final Setting<RotateMode> rotations = new Setting<>("Rotate", RotateMode.Both);
    public static final Setting<Boolean> eventCancel = new Setting<>("CancelEvent", true);
    public static final Setting<Boolean> loop = new Setting<>("Loop", true);
    public static final Setting<Boolean> silentSwap = new Setting<>("SilentSwap", true);
    public static final NumberSetting<Integer> packets = new NumberSetting<>("Packets", 1, 1, 25, 1);
    public static final Setting<Boolean> packetCancel = new Setting<>("CancelEvent", true);
    public static final Setting<Boolean> render = new Setting<>("Render", true);
    public static final NumberSetting<Integer> delayOffset = new NumberSetting<>("Offset", 0, 0, 10, 1);
    public static final Setting<Color> startColor = new Setting<>("StartFill", new Color(0x8DFF0101, true));
    public static final Setting<Color> finishColor = new Setting<>("FinishFill", new Color(0x8C01FF05, true));
    public static final NumberSetting<Float> outlineWidth = new NumberSetting<>("OutlineWidth", 0.0f, 1.5f, 5.0f, 1);
    public static final Setting<NewRender3DUtils.RenderBoxMode> renderMode = new Setting<>("RenderMode", NewRender3DUtils.RenderBoxMode.Fancy);
    public static final Setting<Boolean> debug = new Setting<>("Debug", false);

    private boolean isActive;
    private EnumFacing lastFace;
    private BlockPos lastPos;
    private Block lastBlock;
    private double time = 0;
    private long old = 0;
    private double tickCount = 0;
    private ItemStack item;
    private boolean swapped = false;

    public SpeedMine() {
        registerParents(
                new ParentSetting("Range", false, range, rangeCheck),
                new ParentSetting("Rotation", false, rotations),
                new ParentSetting("Render", false, render, renderMode, delayOffset, startColor, finishColor, outlineWidth),
                new ParentSetting("Misc", false, silentSwap, swing, eventCancel, loop, packets, packetCancel, debug)
        );
    }

    @SubscribeEvent(priority = EventPriority.HIGH)
    public final void onBlockDamage(BlockEvent event){
        if (event.getType() == EventType.Type3 && ((IRenderControllerMP)mc.playerController).getCurBlockDamageMP() > 0.1f) {
            ((IRenderControllerMP)mc.playerController).setHittingBlock(true);
        }

        if(event.getType() == EventType.Type4) {
            if (!canBreakBlockFromPos(event.pos)) return;

            if (swing.getValue()) {
                mc.player.swingArm(EnumHand.MAIN_HAND);
            }

            if (!isActive) {
                if (loop.getValue()) {
                    for (int i = 0; i < packets.getValue(); i++) {
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                    }
                } else {
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                }
                event.setCancelled(eventCancel.getValue());
                isActive = true;
                tickCount = 0;
                lastFace = event.facing;
                lastPos = event.pos;
                lastBlock = mc.world.getBlockState(lastPos).getBlock();
                if (PlayerUtils.getItemStackFromItem(PlayerUtils.getBestItem(lastBlock)) != null){
                    item = PlayerUtils.getItemStackFromItem(PlayerUtils.getBestItem(lastBlock));
                } else {
                    item = mc.player.getHeldItem(EnumHand.MAIN_HAND);
                }

                time = BlockUtils.getMineTime(lastBlock, item);

                if(rotations.getValue() == RotateMode.Hit){
                    RotationUtil.rotateHead(lastPos.getX(), lastPos.getY(), lastPos.getZ(), mc.player);
                }
            }
        }
    }

    @Override
    public void onUpdate(){
        if(nullCheck())return;
        if(isActive && rangeCheck.getValue()){
            double dis = mc.player.getDistanceSq(lastPos);
            if(dis > range.getValue()){
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, lastPos, lastFace));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, lastPos, lastFace));
                isActive = false;
                lastPos = null;
                lastFace = null;
                lastBlock = null;
            }
        }
        if(lastPos != null && lastBlock != null && isActive){
            if(rotations.getValue() == RotateMode.Both){
                RotationUtil.rotateHead(lastPos.getX(), lastPos.getY(), lastPos.getZ(), mc.player);
            }
            if(packetCancel.getValue()) {
                if (loop.getValue()) {
                    for (int i = 0; i < packets.getValue(); i++) {
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, lastPos, lastFace));
                    }
                } else {
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, lastPos, lastFace));
                }
                isActive = true;
            }
            ((IRenderControllerMP)mc.playerController).setBlockHitDelay(0);
            if(mc.world.getBlockState(lastPos).getBlock() != lastBlock){
                if(rotations.getValue() == RotateMode.Break){
                    RotationUtil.rotateHead(lastPos.getX(), lastPos.getY(), lastPos.getZ(), mc.player);
                }
                isActive = false;
                lastPos = null;
                lastFace = null;
                lastBlock = null;
            }
        }
        if(old < System.currentTimeMillis()){
            tickCount++;
            old = System.currentTimeMillis();
        }

        if (silentSwap.getValue() && isActive && lastPos != null) {
            if(tickCount/10 > time - delayOffset.getValue()){
                if (findHotbarItem(item) != -1 && !swapped) {
                    switchToSlot(findHotbarItem(item), true);
                    if (debug.getValue()) ChatUtils.sendClientMessageSimple(ChatFormatting.RED + "Silent swapped");
                    swapped = true;
                }
            }
        }

        //wtf

        if (!isActive && swapped) {
            swapped = false;
            int temp = mc.player.inventory.currentItem;
            switchToSlot(temp + 1, false);
            switchToSlot(temp, false);
            if (debug.getValue()) ChatUtils.sendClientMessageSimple(ChatFormatting.GREEN + "Swapped Back");
        }
    }

    public void switchToSlot(int slot, boolean silent) {
        if (mc.player.inventory.currentItem == slot || slot < 0) {
            return;
        }

        if (silent) {
            mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
            mc.playerController.updateController();
        } else {
            mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
            mc.player.inventory.currentItem = slot;
            mc.playerController.updateController();
        }
    }

    private int findHotbarItem(ItemStack item) {
        for (int i = 0; i < 9; i++) {
            ItemStack stack = mc.player.inventory.getStackInSlot(i);
            if (stack == ItemStack.EMPTY) {
                continue;
            }

            if (item.getItem() == stack.getItem()) {
                return i;
            }
        }
        return -1;
    }

    @Override
    public void onRender3d(RenderEvent3D event) {
        try {
            if(!render.getValue())return;
            if(isActive && lastPos != null){
                Color c = startColor.getValue();
                if(tickCount/10 > time - delayOffset.getValue()){
                    c = finishColor.getValue();
                }
                NewRender3DUtils.renderStandardBox(lastPos, c, renderMode.getValue(), 0.0f, outlineWidth.getValue());
            }
        } catch (Exception e) {e.printStackTrace();}
    }

    private boolean canBreakBlockFromPos(final BlockPos p){
        final IBlockState stateInterface = mc.world.getBlockState(p);
        final Block block = stateInterface.getBlock();
        return block.getBlockHardness(stateInterface, mc.world,  p) != -1;
    }

    private enum RotateMode {
        None,
        Break,
        Hit,
        Both
    }
}
